#include <stdio.h>

void A()
{
    printf("hello\n");
}
void B(void (*ptr)())
{
    ptr();
}

int main()
{         // 函数名A，就是函数A的入口地址。函数名 A 自动转换为函数指针（类型 void (*)()）
    B(A); // 通过函数指针调用 A 函数

    void (*p)() = A; // 定义函数指针 p，指向 A 函数
    B(p);            // 通过函数指针调用 A 函数
    return 0;
}

/*
这段代码可以执行，原因在于C语言中函数名的处理方式以及函数指针的使用规则。下面详细解释：
1. **函数名与函数指针的自动转换**：
   - 在C语言中，函数名（如`A`）在表达式中会自动转换为指向该函数的函数指针（类型为`void (*)()`）。
   - 因此，当我们将`A`作为参数传递给函数`B`时，实际上传递的是函数`A`的地址（即函数指针）。
2. **函数`B`的参数类型**：
   - `void (*ptr)()` 是一个函数指针类型，指向一个没有参数且返回`void`的函数。
   - 所以，`B`函数期望接收一个符合这种类型的函数指针。
3. **调用过程**：
   - 在`main`函数中，`B(A);` 语句将函数名`A`作为参数传递给`B`。
   - 由于自动转换，`A`被转换为函数指针，然后传递给`B`。
   - 在`B`函数内部，通过`ptr()`调用该函数指针，实际上就是调用`A`函数。
4. **函数指针的调用语法**：
   - 在C语言中，函数指针可以通过两种方式调用：
     - 解引用调用：`(*ptr)();`
     - 直接调用：`ptr();`
   - 两种方式都是合法的，且效果相同。代码中使用了直接调用方式。
5. **为什么函数名可以当作函数指针使用？**
   - 这是C语言标准的规定：函数指示符（即函数名）在表达式中除了作为`sizeof`或`&`的操作数时，都会自动转换为指向该函数的指针。
   - 因此，当函数名出现在函数调用的参数列表中时，它会被转换为函数指针。
6. **类型匹配**：
   - 函数`A`的类型是`void ()`，当它被转换为函数指针时，类型为`void (*)()`，这与`B`函数的参数类型`void (*)()`完全匹配。
因此，代码`B(A);`可以正确执行，它等价于：
```c
B(&A);
```
因为`A`和`&A`在函数指针上下文中是等价的（前面已经解释过）。
所以，总结：函数名`A`在传递给函数`B`时，自动转换为函数指针，因此代码能够正确执行。
*/