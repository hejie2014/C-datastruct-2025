#include <stdio.h>

/*
三维数组：B[i][j][k]=*(B[i][j] + K)
                   =*(*(B[i] + j ) + k)  :*(B[i] + j ) --->B[i][j]  一级指针
                =*(*(*(B + i) + j ) + k)  -->*(B + i) + j  &B[i][j]：二级指针*(*(B + i) + j) -->B[i][j]

把 B 作为三级指针，解引用一次或 [ ]，指针都会降一级
比如： (B[i] + j ) -->进行一次* and [] -->所以是一级指针，B[i][j] 也是一级指针

*(*(*(B + i) + j ) + k)-->三次 * （解引用） -》实际的数据（值）

*/
void Func(int *A) {}; // 一维数组作为参数 (int A[])
// 如定义 int B [2][4],不能传入Func2，类型不匹配， 得B[x][3]
void Func2(int (*B)[3]) {}; // 二维数组作为参数 (int B[][3])

// void Func3(int ***C),有误，不能这么写，丢失了步长，执行解引用，指针运算，指针不知道如何移动。
void Func3(int (*C)[2][2]) {}; // 三维数组作为参数 (int C[][2][2])
int main()
{                                         // 数组作为参数会退化成指针
    int A[2] = {1, 2};                    // int *
    int B[2][3] = {{2, 4, 6}, {5, 7, 8}}; // int (*)[3]
    int C[3][2][2] = {{{2, 5}, {7, 9}},
                      {{3, 4}, {6, 1}},
                      {{0, 8}, {11, 13}}}; // int (*)[2][2]
    // 指针声明
    int (*p)[2][2] = C; // p是一个指向包含2个一维数组的二维数组的指针(三级指针)
    printf("&C[0][0][0] = %p\n", &C[0][0][0]);
    printf("C = %p\n", C);
    printf("***C = %d\n", ***C); //***C = 2,C[0][0][0]
    // printf("***C = %p\n", ***C); //***C = 0000000000000002
    printf("*C = %p, C[0] = %p, &C[0][0] = %p\n", *C, C[0], &C[0][0]);               // 二级指针
    printf("**C = %p, C[0][0] = %p, &C[0][0][0] = %p\n", **C, C[0][0], &C[0][0][0]); // 一级指针
    printf("-------------------\n");
    // C[0][1]返回一个一维数组(&C[0][1][0])，+ 1 在移动一个单位就是&C[0][1][1]
    /*
    第一个 0 在第一层（2*2 的二维数组）-》第二个 1 表示在二维数组的第二行--> + 1 表示第二行数组的第二个元素（9）
    */
    printf("*(C[0][1] + 1 )= %d, C[0][1][1] = %d\n", *(C[0][1] + 1), C[0][1][1]); // 9
    // C[0]的地址为400，C[1]的地址为400+(2*2*4)=416, C[1] + 1的地址为416 + (2*4) = 424,
    // C[1]返回 int (*)[2] 的指针，指向一个包含2个一维数组的二维数组
    printf("*(C[1] + 1) = %p, C[1][1] = %p, &C[1][1][0] = %p\n", *(C[1] + 1), C[1][1], &C[1][1][0]); // 相差24个bytes

    return 0;
}