#include <stdio.h>
/*
tips：
二维数组： B[i][j]=*(B[i] + j)  // B[i] + j 等价于 &B[i][j]
                 =*(*(B + i )+j) //*(B + i ) 等价于 B[i]

三维数组：B[i][j][k]=*(B[i][j] + K)
                   =*(*(B[i] + j ) + k)  :*(B[i] + j ) --->B[i][j]  一级指针
                =*(*(*(B + i) + j ) + k)  -->*(B + i) + j  &B[i][j]：二级指针*(*(B + i) + j) -->B[i][j]

把 B 作为三级指针，解引用一次或 [ ]，指针都会降一级
比如： (B[i] + j ) -->进行一次* and [] -->所以是一级指针，B[i][j] 也是一级指针

*(*(*(B + i) + j ) + k)-->三次 * （解引用） -》实际的数据（值）

*/
int main()
{
    int B[2][3] = {{2, 3, 6}, {4, 5, 8}};
    /*
      B[0]与B[1](一级指针)，指向一个一位数组(包括3个int元素)的首地址。
      我们试图用一个不兼容的指针类型来初始化一个'int *'类型的变量。具体来说，我们试图将'int (*)[3]'类型（即指向包含3个整数的数组的指针）赋值给一个'int *'类型（指向整数的指针）的变量。
    */
    // int *p = B;错误，可以理解为B是一个二级指针，而P是一个一级指针，不匹配。
    int (*p)[3] = B;                                                   // p是一个指向包含3个整数的数组的指针
    printf("B = %p, &B[0] = %p\n", B, &B[0]);                          // B是一个二级指针，&B[0]是一级指针的地址，也是一个二级指针。
    printf("*B = %p, B[0] = %p, &B[0][0] = %p\n", *B, B[0], &B[0][0]); // 都是指向二维数组的首地址
    // 这就是为什么之前说指针类型很重要，如果前面不声明p的类型是包含3个整型的一维数组的话，这里计算机就不知道p＋1应该指向哪个地址
    printf("---------------\n");
    printf("B + 1 = %p, &B[1] = %p\n", B + 1, &B[1]);                              // B + 1是指向第二个一维数组的指针，&B[1]是第二个一维数组的地址
    printf("*(B + 1) = %p, B[1] = %p, &B[1][0] = %p\n", *(B + 1), B[1], &B[1][0]); // 都是指向二维数组第二行数组的首地址

    // B + 1-->指针移动一个单位(这个单位是包含3个int元素的一维数组)。*(B + 1)进行解引用，得到每行一维数组的首地址
    //     B+1 与 &B[1] ---》 都是二级指针。
    //    *(B +1) 与 B[1]  与 &B[1][0]  -----》 都是一级指针。
    printf("---------------------\n");
    //*(B+1) -->一个一级指针B[1],返回一个一维数组，+2操作，指针在一维数组中移动2个单位(int字节)
    // 在 B[1]的基础上移动2个int字节，也就是 + 8 bytes；
    /*
     得到还是一个一级指针，这个指针在原来的基础上移动 2 个 int 单位--》也就是&B[1][2]--->
    在进行 一次解引用就得到数组 B[1][2] 的值（8）
    */
    printf("*(B + 1) + 2 = %p\n", *(B + 1) + 2);                  // &B[1][2]
    printf("B[1] + 2 = %p, &B[1][2] = %p\n", B[1] + 2, &B[1][2]); //&B[1][2]

    printf("------------------------\n");
    /*
      B----> int (*)[3](指向一位数组的指针), B[0]---->int *(指向int的指针), B[0][0]---->int
      实际上，对二维数组的数组名解引用并不会得到值，得到的是指向下一层数组的首元素的指针
        还是需要牢记“二维数组就是里面元素是一维数组的一维数组”
        这里可能会疑惑为什么数组名 B 和 *B 返回的是相同的地址
    */
    printf("*(*B + 1)) = %d\n", *(*B + 1)); //(*B + 1)-->&B[0][1]-->解引用-->B[0][1] = 3

    return 0;
}

//  -------一维数组--------
// int main()
// {
//     int A[5] = {1, 3, 5, 7, 9};
//     int *p = A;                          // p 指向数组的第一个元素
//     printf("A = %p\n", A);               // 数组名是数组的首地址
//     printf("p = %p\n", p);               // p指向数组A的首地址
//     printf("*p = %d\n", *p);             // *p是数组A的第一个元素,1
//     printf("*(p + 2) = %d\n", *(p + 2)); // 指针移动2个单位，A[2] = 5
//     // 替换成数组名也是一样；
//     printf("-----------------------\n");
//     // *(A + 2) 等价于 A[i], (A + 2) 等价于 &A[i]
//     printf("A = %p\n", A);               // A指向数组A的首地址
//     printf("*A = %d\n", *A);             // *A是数组A的第一个元素,1
//     printf("*(A + 2) = %d\n", *(A + 2)); // 指针移动2个单位，A[2] = 5

//     return 0;
// }